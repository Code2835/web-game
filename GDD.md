# web-game multi-player

## game
- multiplayer, up to 4 players
- online
- real-time
- lead player
  - pause, restart, quit
  - accepts players
- players
  - join
  - name
- scoring system
- lives
- winner
- timer
- main menu lobby

## tech stack
- html, DOM elements
- css
- js

### forbidden
- canvas

### requirements
- 60 FPS
- use Performance Tool to monitor performance
- use layers to optimize rendering performance
- use requestAnimationFrame to animate
- available from any browser by URL, online from internet
- real-time

## extra
- keyboard controls
- sound effects

# Game Design Document: DOM Zombie Shooter

## 1\. Общее видение (Концепция)

- **Название:** DOM Zombie Shooter (рабочее) 
- **Жанр:** Top-Down Arena Shooter 
- **Платформа:** Web (браузер)
- **Ключевая особенность:** Игра использует исключительно DOM-элементы для рендеринга, `<canvas>` запрещен.
- **Краткое описание:** 4 игрока сражаются на арене друг с другом и с волнами зомби. Основная цель — набрать как можно больше золота и выжить в течение 3 минут. Если после 3 минут остаются выжившие, запускается режим "Последний выживший" с бесконечными волнами зомби.

## 2\. Игровые механики

### 2.1. Основные механики

-   **Перемещение:** Игроки управляют своими персонажами в 8 направлениях (WASD + диагонали).
-   **Стрельба:** Игроки могут стрелять в направлении курсора мыши.
-   **Здоровье и броня:** У каждого игрока есть 3 жизни и до 3 единиц брони. Выстрел от другого игрока сначала снимает броню, затем жизни.
-   **Респаун:** После смерти игрок возрождается в своем стартовом углу с 10-секундной блокировкой движения.
-   **Подбираемые предметы:** На карте случайным образом появляются ящики с патронами, броня и сундуки с золотом.


### 2.2. Игровые сущности (Entities)

-   **Игрок:**
    -   **Жизни:** 3
    -   **Броня:** 0 (максимум 3)
    -   **Патроны:** 10 (начальные)
    -   **Золото:** 0 (начальное)
    -   **Действия:** Двигаться, стрелять.

-   **Зомби (Бонус):**
    -   **Жизни:** 1 (увеличивается с каждой волной в режиме "атаки роя")
    -   **Поведение:** Появляется с края карты, выбирает ближайшего игрока как цель и преследует его. Не меняет цель, пока цель или сам зомби не умрет.
    -   **Атака:** При контакте с игроком обездвиживает его на 3 секунды. Если за это время игрок не убивает зомби, он теряет 1 жизнь (атака игнорирует броню).

-   **Снаряд (Пуля):**
    -   Летит от игрока в направлении курсора.
    -   Исчезает при столкновении с другим игроком, зомби или границей карты.
    -   Наносит 1 урон (снимает 1 броню или 1 жизнь).

-   **Подбираемые предметы (Pickups):**
    -   **Ящик с патронами:** +30 патронов.
    -   **Броня:** +1 к броне (не превышая максимум).
    -   **Сундук с золотом:** +N золота (от 1 до 100).


## 3\. Игровой цикл (Game Loop)

1.  **Лобби:** Игроки подключаются, вводят имена. Хост (создатель игры) запускает матч.
2.  **Начало раунда:** Таймер устанавливается на 3 минуты. Игроки появляются в углах карты.
3.  **Основная фаза (3 минуты):**
    -   Игроки перемещаются, стреляют, собирают предметы.
    -   На карте появляются новые предметы.
    -   (Бонус) Каждые 30 секунд появляются 2 зомби.

4.  **Конец раунда:**
    -   **Если 3 минуты истекли и >1 игрока живы:** Запускается режим "Атака роя зомби". Цель — остаться последним выжившим. Золото больше не имеет значения.
    -   **Если в любой момент остался только 1 игрок:** Этот игрок объявляется победителем.
    -   **Если 3 минуты истекли и <=1 игрока живы:** Побеждает тот, кто выжил и у кого больше золота.


## 4\. Техническая спецификация (Предварительная)

-   **Фронтенд:** React, TypeScript.
-   **Бэкенд:** Node.js, TypeScript.
-   **Сетевое взаимодействие:** WebSocket.
-   **Архитектура:** Клиент-Сервер (Выделенный сервер).
-   **Источник правды (Source of Truth):** Сервер. Состояние игры хранится в RAM сервера.

### 4.1 мировые координаты и адаптивная отрисовка.

У нас есть виртуальная карта размером, например, 1000x1000 единиц. Все объекты на карте (игроки, зомби, предметы) имеют свои координаты (x,y) внутри этой системы. Игроки всегда отправляют и получают координаты в этих мировых единицах.
А уже на стороне клиента, в браузере, мы делаем адаптивную отрисовку. Клиент знает размер своего экрана и переводит мировые координаты в пиксели, проценты или другие единицы, чтобы правильно отобразить всё на своём экране. Например, если ширина карты 1000 мировых единиц, а ширина экрана 1920 пикселей, то 1 мировая единица = 1.92 пикселя.
Это называется **разделение логики и представления**. Сервер отвечает за игровую логику (где кто находится в мировых координатах), а клиент — за то, как это показать на конкретном устройстве.


## 5\. Структуры данных (TypeScript Interfaces) - Work in Progress

### 5.1 Сущности

Это "чертежи" наших данных. Сервер и клиент будут обмениваться объектами именно такой структуры.

```typescript
<span class="selected">// Общее состояние игры, которое сервер рассылает всем клиентам
    
interface GameState {
  gameStatus: 'lobby' | 'in-progress' | 'sudden-death' | 'finished';
  gameTime: number; // Оставшееся время в секундах
  players: { [id: string]: Player };
  bullets: { [id: string]: Bullet };
  items: { [id: string]: Item };
  zombies: { [id: string]: Zombie };
  winner?: string; // ID победившего игрока
}

interface Vector2D {
  x: number;
  y: number;
}

interface Player {
  id: string;
  name: string;
  position: Vector2D;
  rotation: number; // Угол в радианах
  lives: number;
  armor: number;
  ammo: number;
  gold: number;
  isAlive: boolean;
  respawnTimer: number; // &gt;0 если игрок мертв и ждет возрождения
}

interface Bullet {
  id: string;
  ownerId: string;
  position: Vector2D;
  velocity: Vector2D;
}

interface Item {
  id: string;
  type: 'ammo' | 'armor' | 'gold';
  position: Vector2D;
  value?: number; // для золота
}

interface Zombie {
  id: string;
  position: Vector2D;
  lives: number;
  targetId: string;
}

</span><br class="ProseMirror-trailingBreak">
```




## 6\. Сетевой протокол (WebSocket API) - Work in Progress

Описывает, какими "словами" (сообщениями) клиент и сервер общаются друг с другом. Каждое сообщение имеет тип и полезную нагрузку (payload).

Клиенты будут отправлять только **свои действия**, а сервер будет выступать как **источник правды** (Source of Truth), который рассчитывает состояние мира и рассылает его всем. Таким образом, у всех игроков всегда будет синхронизированная, одинаковая "картинка".

1. **Клиент не отправляет "сущность" целиком**. Это слишком много данных. Вместо этого он отправляет только ввод игрока (player input): "Я нажал W и D, и нажал левую кнопку мыши". Это очень лёгкие по весу сообщения. Клиент отправляет их серверу как можно чаще (например, 30-60 раз в секунду).
2. **Сервер получает ввод от всех игроков**. Сервер не обрабатывает каждое сообщение сразу. Он собирает все новые сообщения от всех игроков за короткий промежуток времени (например, 10-20 мс).
3. **Сервер рассчитывает новое состояние мира**. За один "тик" или "кадр" сервера, он:
    - Смотрит, какие действия совершили все игроки.
    - Считает, куда они передвинулись.
    - Проверяет столкновения.
    - Обновляет позиции всех объектов.
    - Рассчитывает новое состояние игры.

4. **Сервер отправляет полное состояние мира**. После всех расчётов, сервер рассылает одно сообщение всем игрокам. Это сообщение содержит полное состояние мира (GameState из твоего GDD.md): где находится каждый игрок, где пули, сколько у кого здоровья и т.д. Клиент просто берёт эти данные и рисует картинку.

### 6.1. Сообщения от Клиента к Серверу (C2S)

-   **`join_game`**: Отправляется один раз при подключении.
    -   **Payload:** `{ name: string }`
-   **`player_input`**: Отправляется на каждом кадре, когда игрок совершает действие.
    -   **Payload:** `{ keys: string[], mouseAngle: number }` (например, `keys: ['w', 'a']`)
-   **`player_shoot`**: Отправляется при клике мыши.
    -   **Payload:** `{ angle: number }`


### 6.2. Сообщения от Сервера к Клиенту (S2C)

-   **`game_state`**: Основное сообщение. Отправляется ~20-30 раз в секунду всем игрокам, содержит полное состояние игрового мира.
    -   **Payload:** `GameState` (см. раздел 5)
-   **`player_joined`**: Информационное сообщение для всех, когда новый игрок зашел в лобби.
    -   **Payload:** `{ id: string, name: string }`
-   **`player_left`**: Информационное сообщение для всех, когда игрок отключается.
    -   **Payload:** `{ id: string }`
-   **`init`**: Первое сообщение, которое получает клиент. Содержит его уникальный ID.
    -   **Payload:** `{ playerId: string }`

## MVP
- Сервер, к которому можно подключиться.
  - **Присоединение**: Игрок заходит по URL, вводит имя (уникальное).
  - **Лидер**: Один игрок становится "хостом" (лидером).
  - **Старт**: Лидер может начать игру, когда подключилось от 2 до 4 игроков. Это критично, так как это первая "серверная" логика, которую мы будем писать.
- Игроки могут присоединиться к игре и получить уникальное имя.
- Игроки появляются на карте в виде div-ов.
- Игроки могут двигаться.
  - **Управление**: Игроки должны двигаться с помощью клавиатуры (это обязательное требование из TEST.md в секции Extra, но для MVP это must-have).
  - **Плавность**: Движение должно быть "jank-free" и работать на 60 FPS. Это значит, что нам нужно правильно настроить requestAnimationFrame на клиенте и продумать, как часто сервер будет отправлять обновления.
- Сервер получает новые координаты и рассылает их всем остальным игрокам.
